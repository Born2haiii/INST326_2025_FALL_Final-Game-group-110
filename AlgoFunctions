


# Brandon fucntion that checks when an item is created

Recipe_STONE_Sword ={ 
                "stone sword" : 
                [
                ['_','_','STONE'],
                ['_','STONE','_'],
                ['STICK','_','_']]}

item_dict = {"WOOD": "W",
             "WOOD_PLANK": "P",
             "STONE": "S",
             "STICK": "T",
             "IRON_INGOT": "I",
             "GOLD_INGOT": "G",
             "DIAMOND": "D"}

def validate_inventory_action(inventory, material):
    """
    Adib Aayan
    Technique Used: Conditional branching + dictionary state tracking

    Checks whether the user can place a material based on remaining inventory.

    Args:
        inventory (dict): material -> remaining count
        material (str): material the user wants to place

    Returns:
        bool: True if placement is allowed, False otherwise
    """

    if material not in inventory:
        return False

    if inventory[material] <= 0:
        return False

    return True


    
def Gameboard(): # fake function 
    board =[
            ['_','_','STONE'],
            ['_','STONE','_'],
            ['STICK','_','_']]
    return board
    
    
def attempts(userInput = 3): # fake function but could be an algo
    
    return 3

def Crafting_check(board,recipeDict,attempted):
    """ Checks if the current board has the correct matches as the recipe to 
    create an item
    
    This function compares every coordinate (collum and row) of the board to the 
    coordinate of the recipe. If when itterated through all the coordinates and
    there is a complete match then the item in crafted
    
    Args:
        board (list(list[str])): our creating board represented as a nested list of 
        3 list with 3 elements.
        recipeDict: (dict): a dict containing crafting recipes 
        attempted (int): the number of attemps the user took to craft the item
    
    Returns:
        str: A message showing the complete board , attempts taken 
    
    
    """
    recipe = recipeDict["stone sword"]
    for rows in range(len(board)):
        for collum in range(len(board[rows])):
            if board [rows][collum] != recipe[rows][collum]:
                return 
            
        return f'{board} took {attempted} atempts to craft the sword'
            # we can itterate over the outer list to print row by row 
                    
            
    
    #if row/collum cordinate = same as recipe this is true
    # itterate through every row and collum if the recipe and board have the same 
    # values at the cordinates the item is crafted 


   
    """"
    if board == recipe:
        return f'{board} took {attempts} atempts to craft the sword }"""
    
# *** Yushen's function that prints the gameboard in the console

def draw_grid(grid):
    print("   0   1   2")
    for r in range(3):
        row_str = f"{r} "
        for c in range(3):
            cell = grid[r][c]
            if cell == "_":
                symbol = "_"
            else:
                symbol = item_dict[cell]
            row_str += f"[{symbol}] "
        if r == 1:
            row_str += " -->  Unkwown"
        print(row_str)
    print()
    
def draw_screen(grid):
    print("=== CRAFTING TABLE ===")
    draw_grid(grid)
    print("Legend: W = wood, T = stick, P = wood plank, S = stone, I = iron ingot, G = gold ingot, D = diamond")
    print()
        
if __name__ == "__main__":
    board = Gameboard()
    atempted = attempts(3)
    game1 = Crafting_check(board,Recipe_STONE_Sword,atempted)
    print(draw_screen(board))
    
       

#Alg 2 checks the fastest path 

#set values for the optimal paths
OPTIMAL_PATHS = {
    "stick": [
        "place wood at 4",
        "place wood at 7"
    ],
    "plank": [
        "place log at 0"
    ],
    "stone_pickaxe": [
        "place stone at 0",
        "place stone at 1",
        "place stone at 2",
        "place stick at 4",
        "place stick at 7"
    ]
}

def analyze_fastest_path(crafted_item, user_path):
    """
    Compare user's crafting steps with the optimal steps.
    Returns:
        - is_optimal (bool)
        - extra_steps (int)
        - recommended_path (list of strings)
    """
    
    if crafted_item not in OPTIMAL_PATHS:
        return {
            "error": "No optimal path defined for this item."
        }

    optimal_path = OPTIMAL_PATHS[crafted_item]
    optimal_len = len(optimal_path)
    user_len = len(user_path)

    is_optimal = (user_len == optimal_len)
    extra_steps = max(0, user_len - optimal_len)

    return {
        "crafted_item": crafted_item,
        "is_optimal": is_optimal,
        "user_steps": user_len,
        "optimal_steps": optimal_len,
        "extra_steps": extra_steps,
        "recommended_path": optimal_path
    }

#testing example

if __name__ == "__main__":

    #user made these moves:
    user_actions = [
        "place wood at 4",
        "place wood at 7",
        "remove item at 8"   # not needed 
    ]

    result = analyze_fastest_path("stick", user_actions)

    print("RESULT:")
    for k, v in result.items():
        print(f"{k}: {v}")
