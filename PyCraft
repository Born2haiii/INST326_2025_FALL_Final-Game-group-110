import re 



Recipe_STONE_Sword ={
                "stone sword" : 
                [
                ['_','_','STONE'],
                ['_','STONE','_'],
                ['STICK','_','_']]}

Recipe_Wood_Sword ={ 
                "wood sword" : 
                [
                ['_','_','WOOD'],
                ['_','WOOD','_'],
                ['STICK','_','_']]}

Recipe_Diamond_Sword ={ 
                "diamond sword" : 
                [
                ['_','_','DIAMOND'],
                ['_','DIAMOND','_'],
                ['STICK','_','_']]}



Pickaxe_Diamond = {"diamond pickaxe" : 
                [
                ['DIAMOND','DIAMOND','DIAMOND'],
                ['_','STICK','_'],
                ['_','STICK','_']]}


Pickaxe_WOOD = {"wood pickaxe" : 
                [
                ['WOOD','WOOD','WOOD'],
                ['_','STICK','_'],
                ['_','STICK','_']]}

Pickaxe_STONE = {"stone pickaxe" : 
                [
                ['STONE','STONE','STONE'],
                ['_','STICK','_'],
                ['_','STICK','_']]}

SWORD_recipes = (Recipe_Diamond_Sword |
                 Recipe_STONE_Sword | 
                 Recipe_Wood_Sword)

PIX_recipes = (Pickaxe_Diamond |
                 Pickaxe_WOOD | 
                 Pickaxe_STONE)

total_recipes = ( PIX_recipes | SWORD_recipes)

materials = {"STONE", "WOOD", "STICK", "DIAMOND"}

#Optimal paths 
OPTIMAL_PATHS = {
    "stone sword": [
        "place STONE at C1",
        "place STONE at B2",
        "place STICK at A3"
    ],
    "wood sword": [
        "place WOOD at C1",
        "place WOOD at B2",
        "place STICK at A3"
    ],
    "diamond sword": [
        "place DIAMOND at C1",
        "place DIAMOND at B2",
        "place STICK at A3"
    ],
    "diamond pickaxe": [
        "place DIAMOND at A1",
        "place DIAMOND at B1",
        "place DIAMOND at C1",
        "place STICK at B2",
        "place STICK at B3"
    ],
    "wood pickaxe": [
        "place WOOD at A1",
        "place WOOD at B1",
        "place WOOD at C1",
        "place STICK at B2",
        "place STICK at B3"
    ],
    "stone pickaxe": [
        "place STONE at A1",
        "place STONE at B1",
        "place STONE at C1",
        "place STICK at B2",
        "place STICK at B3"
    ]
}






# maybe would look beter with utf emojis

Directions = {
    "A1":(0,0), "B1":(0,1), "C1":(0,2),
    "A2":(1,0), "B2":(1,1), "C2":(1,2),
    "A3":(2,0), "B3":(2,1), "C3":(2,2),
}

def validate_and_consume_material(inventory, material):
    """
    Adib Aayan

    Ensures the player has the requested material available.
    If valid, consumes one unit of the material.

    Args:
        inventory (dict): material -> remaining count
        material (str): material being placed

    Returns:
        bool: True if placement is allowed, False otherwise
    """
    if material not in inventory:
        return False

    if inventory[material] <= 0:
        return False

    inventory[material] -= 1
    return True



    
class Gameboard: # fake function 
    
    
    """example
    INPUT: " A1,DIAMOND"
    """
    
    def __init__(self):
        self.board =[
                ['_','_','_'],
                ['_','_','_'],
                ['_','_','_']]
        
        self.action_history = []
        
        # Player inventory (limited resources)
        self.inventory = {
            "STONE": 6,
            "WOOD": 6,
            "STICK": 4,
            "DIAMOND": 2
        }

        
        
    def get_action_history(self):  #returns the user path 
        """Returns the complete action history"""
        return self.action_history
    
    def Player_board(self):
        """returns the current board"""
        return self.board
        
        
    def placing(self,input):
        """_summary_

        Args:
            input (_type_): _description_
        """
        
        if ',' not in input:
            print("Please enter a valid input in such format A1,STONE")
            return False
        
        raw_coord , raw_material = input.upper().split(",",1)
        coord = raw_coord.strip()
        material = raw_material.strip()

        if coord not in Directions:
            print("This coordinate is out of bounds")
            return False

        if material not in materials:
            print("Enter a valid material")
            return False

        # Adib: inventory algorithm
        if not validate_and_consume_material(self.inventory, material):
            print(f"Out of {material}! Choose a different material.")
            return False

        row, col = Directions[coord]
        self.board[row][col] = material

        
        #records the users actions "place material at x location" to check that statement at the end for optimal path
        action = f"place {material} at {coord}"
        self.action_history.append(action) #adds the actions
        
        return True
    
    def undo_last_action(self):
        """
        Adib Aayan
        Technique Used: String parsing, conditionals, state reversal

        Undoes the player's most recent placement by:
        - Removing the item from the board
        - Restoring the item to the inventory
        - Removing the action from the action history

        Returns:
            bool: True if undo succeeded, False if no action to undo
        """

        if not self.action_history:
            print("No actions to undo.")
            return False

        last_action = self.action_history.pop()

        # Expected format: "place MATERIAL at COORD"
        try:
            _, material, _, coord = last_action.split()
        except ValueError:
            print("Unable to undo last action.")
            return False

        if coord not in Directions:
            return False

        row, col = Directions[coord]

        # Clear board cell
        self.board[row][col] = "_"

        # Restore inventory
        self.inventory[material] += 1

        print(f"Undid action: {last_action}")
        return True


    def panel(self, lines, max_width, title=""):
        """
        Formats a list of strings into a fixed-width panel with an optional title.

        Args:
            lines (list[str]): A list of strings to be displayed inside the panel.
            max_width (int): The maximum width allowed for each line.
            title (str, optional): A title to be displayed at the top of the panel, emtpy string by default.

        Returns:
            list[str]: A list of formatted strings, each having the same width.
        """

        raw = ([title.center(max_width)] if title else []) + lines
        longest = max(raw, key=len) if raw else ""
        width = min(max_width, len(longest))

        return [s[:width].ljust(max_width) for s in raw]
    
    def print_game(self, left_width=34, right_width=44):
        """
        Displays the current game board along with helpful instructions and
        game information.

        Args:
            left_width (int, optional): The width of the game board panel.
                Defaults to 34.
            right_width (int, optional): The width of the hint panel.
                Defaults to 44.

        Returns:
            None: This function prints the game state directly to the console.
        """
        header = "      A        B        C"
        border = "  ----------------------------"

        board_lines = [header, border]

        for r in range(3):
            board_lines.append(
            f"{r + 1} |" + "|".join(f" {('_' if cell == '_' else cell):7}" for cell in self.board[r]) + "|")
            board_lines.append(border)

        left_panel = self.panel(board_lines, left_width, title="========== CRAFTING ==========")

        coords_grid = ["A1 B1 C1", "A2 B2 C2", "A3 B3 C3"]
        last_move = self.action_history[-1] if self.action_history else " "
        
        
        info_lines = [
            "*Capitalization DOES not MaTTEr",
            "",
            "Type \"A1, STONE\" to place a stone on grid A1",
            "",
            "Materials: STONE, WOOD, STICK, DIAMOND",
            "",
            "Available coordinates:",
            *coords_grid,
            "",
            "Last move:",
            last_move
        ]
        
        right_panel = self.panel(info_lines, right_width, title="========== HINTS ==========")

        height = max(len(left_panel), len(right_panel))
        for i in range(height):
            left = left_panel[i] if i < len(left_panel) else " " * left_width
            right = right_panel[i] if i < len(right_panel) else " " * right_width
            print(left + "  ||  " + right)


    def Print(self):

        """"Example combos 
                
                - `B2,STICK` - Places STICK at center
                - `C3,DIAMOND` - Places DIAMOND at bottom-right corner
                - `A3,WOOD` - Places WOOD at bottom-left corner
            """
        print("\n========== PyCraft ==========")
        print("Valid coordinates: A1â€“C3")
        print("Materials: STONE, WOOD, STICK, DIAMOND")
        print('Example: Type "A1, STONE" to place a stone on A1')

        coords = ["A1","B1","C1","A2","B2","C2","A3","B3","C3"]
        print("Available coordinates:", " ".join(coords))

        if self.action_history:
            print("Last move:", self.action_history[-1])
        else:
            print("Last move: (none yet)")

        row_names = ["1", "2", "3"]
        print("\n      A        B        C")
        print("  ----------------------------")

        for r in range(3):
            row = self.board[r]
            row_label = row_names[r]

            pretty_row = [("_" if cell == "_" else cell) for cell in row]

            formatted_row = "|".join([f" {item:7}" for item in pretty_row])
            print(f"{row_label} |{formatted_row}|")
            
        
            print("  -----------------------------")
    
    






def Crafting_check(board, recipeDict, attempted):
    """
    Adib Aayan
    Technique Used: Nested iteration + conditional branching

    Checks whether the current 3x3 board matches any known crafting recipe.

    Args:
        board (list[list[str]]): Current game board
        recipeDict (dict): Dictionary mapping item names to 3x3 patterns
        attempted (int): Number of attempts used

    Returns:
        str or None: Success message if a recipe matches, otherwise None
    """

    # Loop through each possible recipe
    for item_name, recipe in recipeDict.items():
        match = True

        # Compare each cell in the 3x3 grid
        for r in range(3):
            for c in range(3):
                if board[r][c] != recipe[r][c]:
                    match = False
                    break
            if not match:
                break

        # If every cell matched, crafting succeeded
        if match:
            return f"\n You have crafted a {item_name} in {attempted} attempts!"

    return None

            # we can itterate over the outer list to print row by row 
                    
            
    
    #if row/collum cordinate = same as recipe this is true
    # itterate through every row and collum if the recipe and board have the same 
    # values at the cordinates the item is crafted 
            
   
   
        
def game():
    """this where the instance of gameboard will be made """
    gb = Gameboard()
    max_attempts = 9
    attempts_used = 0
    
            
    
    while attempts_used < max_attempts:
        gb.print_game()

        user = input(
            f"Placement {attempts_used + 1}/{max_attempts} : Please press Q to Quit "
            
        ).strip()

        if user.upper() == "Q":
            return

        if user.upper() == "U":
            gb.undo_last_action()
            continue


        if not gb.placing(user):
            continue
        
        attempts_used += 1 
        Checking = Crafting_check(gb.Player_board(), total_recipes, attempts_used)
        
        if Checking:
            gb.print_game()
            print(Checking)
         
            #analyzes the path after crafting a
            analysis = get_crafting_analysis(Checking, gb.get_action_history())
            
           
           
            print("\n=== Path Analysis ===")
            if "error" in analysis:
                print(analysis["error"])
            else:
                print(f"Crafted item: {analysis['crafted_item']}")
                print(f"Your steps: {analysis['user_steps']}")
                print(f"Optimal steps: {analysis['optimal_steps']}")
                print(f"Extra steps: {analysis['extra_steps']}")
                print(f"Efficiency: {analysis['efficiency_percentage']}%")
                print("Recommended optimal path:")
                for step in analysis["recommended_path"]:
                    print("  -", step)
            print("=====================\n")

            #person whos responsible for printing will then use the results of analysis in they print function. Analysis is a dictionary
            
            return
        
        

def analyze_fastest_path(crafted_item, user_path):
    """
    Written by Ibukun Adenuga
    Technique Used: Conditional expressions, round, max
    
    Compare user's crafting steps with the optimal steps.
    
    Args:
        crafted_item (str): The name of the item that was crafted
        user_path (list): List of user actions (e.g., ["place STONE at A1", ...])
    
    Returns:
        dict: Contains analysis results:
            - crafted_item: name of the crafted item
            - is_optimal: True if user took optimal number of steps
            - user_steps: number of steps user took
            - optimal_steps: minimum steps needed
            - extra_steps: how many extra steps were taken
            - efficiency_percentage: what % efficient the user was
            - recommended_path: the optimal path for reference
    """
    
    
    error = {"error": f"No optimal path defined for '{crafted_item}'."} if crafted_item not in OPTIMAL_PATHS else None
    if error:
        return error
    
    

    optimal_path = OPTIMAL_PATHS[crafted_item]
    optimal_len = len(optimal_path)
    user_len = len(user_path)

    is_optimal = (user_len == optimal_len)
    extra_steps = max(0, user_len - optimal_len)
    
    # Calculate efficiency percentage
    efficiency = (optimal_len / user_len) * 100 if user_len > 0 else 0.0

    return {
        "crafted_item": crafted_item,
        "is_optimal": is_optimal,
        "user_steps": user_len,
        "optimal_steps": optimal_len,
        "extra_steps": extra_steps,
        "efficiency_percentage": round(efficiency, 1),
        "recommended_path": optimal_path
    }
    
    
        
def get_crafting_analysis(success_message, action_history):
    """
    Author: Ibukun Adenuga
    Technique Used: Regex
    Intended as a helper function to the main analysis function, used in within the game function to 
    extract the infromation from the users message & action history
    
    Args:
        success_message (str): The success message from Crafting_check() 
        action_history (list): List of user actions from the game board
    
    Returns:
        dict: Analysis results from analyze_fastest_path(), or error dict if item not found
    """
    match = re.search(r'crafted a (.+?) in', success_message)
    
    if match:
        item_name = match.group(1)
        return analyze_fastest_path(item_name, action_history)
    else:
        return {"error": "Could not extract item name from success message"}
    
    
    
        
def menu():
    while True:
        print('==== PyCraft====')
        print("\n 1. Start Game ")
        print("\n 2. End Game ")
        
        menu_input = input("Please choose 1 or 2: ").strip()
        
        if menu_input == "1":
            game()
            
        elif menu_input == "2":
            break
    
    
    
if __name__ == "__main__":
 menu()


       
