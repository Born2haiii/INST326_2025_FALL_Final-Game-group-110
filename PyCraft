import re 



Recipe_STONE_Sword ={
                "stone sword" : 
                [
                ['_','_','STONE'],
                ['_','STONE','_'],
                ['STICK','_','_']]}

Recipe_Wood_Sword ={ 
                "wood sword" : 
                [
                ['_','_','WOOD'],
                ['_','WOOD','_'],
                ['STICK','_','_']]}

Recipe_Diamond_Sword ={ 
                "diamond sword" : 
                [
                ['_','_','DIAMOND'],
                ['_','DIAMOND','_'],
                ['STICK','_','_']]}



Pickaxe_Diamond = {"diamond pickaxe" : 
                [
                ['DIAMOND','DIAMOND','DIAMOND'],
                ['_','STICK','_'],
                ['_','STICK','_']]}


Pickaxe_WOOD = {"wood pickaxe" : 
                [
                ['WOOD','WOOD','WOOD'],
                ['_','STICK','_'],
                ['_','STICK','_']]}

Pickaxe_STONE = {"stone pickaxe" : 
                [
                ['STONE','STONE','STONE'],
                ['_','STICK','_'],
                ['_','STICK','_']]}

SWORD_recipes = (Recipe_Diamond_Sword |
                 Recipe_STONE_Sword | 
                 Recipe_Wood_Sword)

PIX_recipes = (Pickaxe_Diamond |
                 Pickaxe_WOOD | 
                 Pickaxe_STONE)

total_recipes = ( PIX_recipes | SWORD_recipes)

materials = {"STONE", "WOOD", "STICK", "DIAMOND"}

#Optimal paths 
OPTIMAL_PATHS = {
    "stone sword": [
        "place STONE at C1",
        "place STONE at B2",
        "place STICK at A3"
    ],
    "wood sword": [
        "place WOOD at C1",
        "place WOOD at B2",
        "place STICK at A3"
    ],
    "diamond sword": [
        "place DIAMOND at C1",
        "place DIAMOND at B2",
        "place STICK at A3"
    ],
    "diamond pickaxe": [
        "place DIAMOND at A1",
        "place DIAMOND at B1",
        "place DIAMOND at C1",
        "place STICK at B2",
        "place STICK at B3"
    ],
    "wood pickaxe": [
        "place WOOD at A1",
        "place WOOD at B1",
        "place WOOD at C1",
        "place STICK at B2",
        "place STICK at B3"
    ],
    "stone pickaxe": [
        "place STONE at A1",
        "place STONE at B1",
        "place STONE at C1",
        "place STICK at B2",
        "place STICK at B3"
    ]
}






# maybe would look beter with utf emojis

Directions = {
    "A1":(0,0), "B1":(0,1), "C1":(0,2),
    "A2":(1,0), "B2":(1,1), "C2":(1,2),
    "A3":(2,0), "B3":(2,1), "C3":(2,2),
}


    
class Gameboard: # fake function 
    
    
    """example
    INPUT: " A1,DIAMOND"
    """
    
    def __init__(self):
        self.board =[
                ['_','_','_'],
                ['_','_','_'],
                ['_','_','_']]
        
        self.action_history = [] #tracks the user paths 
        
        
    def get_action_history(self):  #returns the user path 
        """Returns the complete action history"""
        return self.action_history
    
    def Player_board(self):
        """returns the current board"""
        return self.board
        
        
    def placing(self,input):
        """_summary_

        Args:
            input (_type_): _description_
        """
        
        if ',' not in input:
            print("Please enter a valid input in such format A1,STONE")
            return False
        
        raw_coord , raw_material = input.upper().split(",",1)
        coord = raw_coord.strip()
        material = raw_material.strip()

        if coord not in Directions:
            print("This coordinate is out of bounds")
            return False

        if material not in materials:
            print("Enter a valid material")
            return False
        
        row,col = Directions[coord]
        self.board[row][col] = material
        
        #records the users actions "place material at x location" to check that statement at the end for optimal path
        action = f"place {material} at {coord}"
        self.action_history.append(action) #adds the actions
        
        return True

    def panel(self, lines, max_width, title=""):

        raw = ([title.center(max_width)] if title else []) + lines
        longest = max(raw, key=len) if raw else ""
        width = min(max_width, len(longest))

        return [s[:width].ljust(max_width) for s in raw]
    
    def print_game(self, left_width=34, right_width=44):
 
        header = "      A        B        C"
        border = "  ----------------------------"

        board_lines = [header, border]

        for r in range(3):
            board_lines.append(
            f"{r + 1} |" + "|".join(f" {('_' if cell == '_' else cell):7}" for cell in self.board[r]) + "|")
            board_lines.append(border)

        left_panel = self.panel(board_lines, left_width, title="========== CRAFTING ==========")

        coords_grid = ["A1 B1 C1", "A2 B2 C2", "A3 B3 C3"]
        last_move = self.action_history[-1] if self.action_history else " "
        
        
        info_lines = [
            "*Capitalization DOES not MaTTEr",
            "",
            "Type \"A1, STONE\" to place a stone on grid A1",
            "",
            "Materials: STONE, WOOD, STICK, DIAMOND",
            "",
            "Available coordinates:",
            *coords_grid,
            "",
            "Last move:",
            last_move
        ]
        
        right_panel = self.panel(info_lines, right_width, title="========== HINTS ==========")

        height = max(len(left_panel), len(right_panel))
        for i in range(height):
            left = left_panel[i] if i < len(left_panel) else " " * left_width
            right = right_panel[i] if i < len(right_panel) else " " * right_width
            print(left + "  ||  " + right)


    def Print(self):

        print("\n========== PyCraft ==========")
        print("Valid coordinates: A1â€“C3")
        print("Materials: STONE, WOOD, STICK, DIAMOND")
        print('Example: Type "A1, STONE" to place a stone on A1')

        coords = ["A1","B1","C1","A2","B2","C2","A3","B3","C3"]
        print("Available coordinates:", " ".join(coords))

        if self.action_history:
            print("Last move:", self.action_history[-1])
        else:
            print("Last move: (none yet)")

        row_names = ["1", "2", "3"]
        print("\n      A        B        C")
        print("  ----------------------------")

        for r in range(3):
            row = self.board[r]
            row_label = row_names[r]

            pretty_row = [("_" if cell == "_" else cell) for cell in row]

            formatted_row = "|".join([f" {item:7}" for item in pretty_row])
            print(f"{row_label} |{formatted_row}|")
            
        
            print("  -----------------------------")
    
    
    
def attempts(userInput = 0): # NEEDS TO GET IMPLEMENTED ***
    
    
    
    return 9





def Crafting_check(board,recipeDict,attempted):
    """ Checks if the current board has the correct matches as the recipe to 
    create an item
    
    This function compares every coordinate (collum and row) of the board to the 
    coordinate of the recipe. If when itterated through all the coordinates and
    there is a complete match then the item in crafted
    
    Args:
        board (list(list[str])): our creating board represented as a nested list of 
        3 list with 3 elements.
        recipeDict: (dict): a dict containing crafting recipes 
        attempted (int): the number of attemps the user took to craft the item
    
    Returns:
        str: A message showing the complete board , attempts taken 
    
    
    """
    for item  in recipeDict:
        recipe = recipeDict[item]
        
        match = True
        for r in range(3):
            for c in range(3):
                if board[r][c] != recipe[r][c]:
                    match = False
                    break
            if not match:
                break
        if match:
                return f"\n You have crafted a {item} in {attempted} attempts!"
    return None
            # we can itterate over the outer list to print row by row 
                    
            
    
    #if row/collum cordinate = same as recipe this is true
    # itterate through every row and collum if the recipe and board have the same 
    # values at the cordinates the item is crafted 
            
   
   
        
def game():
    """this where the instance of gameboard will be made """
    gb = Gameboard()
    max_attempts = 9
    attempts_used = 0
    
            
    
    while attempts_used < max_attempts:
        gb.print_game()

        user = input(
            f"Placement {attempts_used + 1}/{max_attempts} : Please press Q to Quit "
            
        ).strip()

        if user.upper() == "Q":
            return

        if not gb.placing(user):
            continue
        
        attempts_used += 1 
        Checking = Crafting_check(gb.Player_board(), total_recipes, attempts_used)
        
        if Checking:
            gb.print_game()
            print(Checking)
         
            #analyzes the path after crafting 
            analysis = get_crafting_analysis(Checking, gb.get_action_history())
            
           
           
            print("\n=== Path Analysis ===")
            if "error" in analysis:
                print(analysis["error"])
            else:
                print(f"Crafted item: {analysis['crafted_item']}")
                print(f"Your steps: {analysis['user_steps']}")
                print(f"Optimal steps: {analysis['optimal_steps']}")
                print(f"Extra steps: {analysis['extra_steps']}")
                print(f"Efficiency: {analysis['efficiency_percentage']}%")
                print("Recommended optimal path:")
                for step in analysis["recommended_path"]:
                    print("  -", step)
            print("=====================\n")

            #person whos responsible for printing will then use the results of analysis in they print function. Analysis is a dictionary
            
            return
        
        

def analyze_fastest_path(crafted_item, user_path):
    """
    Written by Ibukun Adenuga
    Technique Used: Conditional expressions
    
    Compare user's crafting steps with the optimal steps.
    
    Args:
        crafted_item (str): The name of the item that was crafted
        user_path (list): List of user actions (e.g., ["place STONE at A1", ...])
    
    Returns:
        dict: Contains analysis results:
            - crafted_item: name of the crafted item
            - is_optimal: True if user took optimal number of steps
            - user_steps: number of steps user took
            - optimal_steps: minimum steps needed
            - extra_steps: how many extra steps were taken
            - efficiency_percentage: what % efficient the user was
            - recommended_path: the optimal path for reference
    """
    
    
    error = {"error": f"No optimal path defined for '{crafted_item}'."} if crafted_item not in OPTIMAL_PATHS else None
    if error:
        return error
    
    

    optimal_path = OPTIMAL_PATHS[crafted_item]
    optimal_len = len(optimal_path)
    user_len = len(user_path)

    is_optimal = (user_len == optimal_len)
    extra_steps = max(0, user_len - optimal_len)
    
    # Calculate efficiency percentage
    efficiency = (optimal_len / user_len) * 100 if user_len > 0 else 0.0

    return {
        "crafted_item": crafted_item,
        "is_optimal": is_optimal,
        "user_steps": user_len,
        "optimal_steps": optimal_len,
        "extra_steps": extra_steps,
        "efficiency_percentage": round(efficiency, 1),
        "recommended_path": optimal_path
    }
    
    
        
def get_crafting_analysis(success_message, action_history):
    """
    Author: Ibukun Adenuga
    Technique Used: Regex
    Intended as a helper function to the main analysis function, used in within the game function to 
    extract the infromation from the users message & action history
    
    Args:
        success_message (str): The success message from Crafting_check() 
        action_history (list): List of user actions from the game board
    
    Returns:
        dict: Analysis results from analyze_fastest_path(), or error dict if item not found
    """
    match = re.search(r'crafted a (.+?) in', success_message)
    
    if match:
        item_name = match.group(1)
        return analyze_fastest_path(item_name, action_history)
    else:
        return {"error": "Could not extract item name from success message"}
    
    
    
        
def menu():
    while True:
        print('==== PyCraft====')
        print("\n 1. Start Game ")
        print("\n 2. End Game ")
        
        menu_input = input("Please choose 1 or 2: ").strip()
        
        if menu_input == "1":
            game()
            
        elif menu_input == "2":
            break
    
    
    
if __name__ == "__main__":
 menu()


       
